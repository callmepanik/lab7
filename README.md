# lab7
Одним из видов взаимодействия между процессами в операционных системах является обмен сообщениями. Под сообщением понимается последовательность байтов, передаваемая от одного процесса другому.
В операционных системах типа UNIX есть 3 вида межпроцессорных взаи- модействий: общеюниксные (именованные каналы, сигналы), System V Interface Definition (SVID — разделяемая память, очередь сообщений, семафоры) и BSD (со- кеты).
Для передачи данных между неродственными процессами можно использовать механизм именованных каналов (named pipes). Данные передаются по принципу FIFO (First In First Out) (первым записан — первым прочитан), поэтому они на- зываются также FIFO pipes или просто FIFO. Именованные каналы отличаются от неименованных наличием идентификатора канала, который представлен как спе- циальный файл (соответственно имя именованного канала — это имя файла). По- скольку файл находится на локальной файловой системе, данное IPC используется внутри одной системы.
Файлы именованных каналов создаются функцией mkfifo(3).
#include <sys/types.h> #include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
Первый параметр — имя файла, идентифицирующего канал, второй параметр — маска прав доступа к файлу.
После создания файла канала процессы, участвующие в обмене данными, долж- ны открыть этот файл либо для записи, либо для чтения. При закрытии файла сам канал продолжает существовать. Для того чтобы закрыть сам канал, нужно удалить его файл, например с помощью вызова unlink(2).
Рассмотрим работу именованного канала на примере системы клиент–сервер. Сервер создаёт канал, читает из него текст, посылаемый клиентом, и выводит его на терминал.
Вызов функции mkfifo() создаёт файл канала (с именем, заданным макросом
FIFO_NAME):
mkfifo(FIFO_NAME, 0600);
В качестве маски доступа используется восьмеричное значение 0600, разреша- ющее процессу с аналогичными реквизитами пользователя чтение и запись. Можно также установить права доступа 0666.
Открываем созданный файл для чтения:
f = fopen(FIFO_NAME, O_RDONLY);
Ждём сообщение от клиента. Сообщение читаем с помощью функции read() и печатаем на экран. После этого удаляется файл FIFO_NAME и сервер прекращает работу.
Клиент открывает FIFO для записи как обычный файл:
f = fopen(FIFO_NAME, O_WRONLY); 
 
Посылаем сообщение серверу с помощью функции write().
Для создания файла FIFO можно использовать более общую функцию mknod(2), предназначенную для создания специальных файлов различных типов (FIFO, сокеты, файлы устройств и обычные файлы для хранения данных).
#include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h>

int mknod(const char *pathname, mode_t mode, dev_t dev);
Тогда, вместо
mkfifo(FIFO_NAME, 0600);
пишем
mknod(FIFO_NAME, S_IFIFO | 0600, 0);
Каналы представляют собой простое и удобное средство передачи данных, кото- рое, однако, подходит не во всех ситуациях. Например, с помощью каналов доволь- но трудно организовать обмен асинхронными сообщениями между процессами.

6.3	Пример программы

6.3.1	Файл common.h
/*
common.h - заголовочный файл со стандартными определениями
*/

#ifndef   COMMON_H  
#define   COMMON_H  

#include <stdio.h> #include <stdlib.h> #include <string.h> #include <errno.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h>

#define FIFO_NAME	"/tmp/fifo"
#define MAX_BUFF	80

#endif /*   COMMON_H */

6.3.2	Файл server.c
/*
server.c - реализация сервера
*
чтобы запустить пример, необходимо:
запустить программу server на одной консоли;
запустить программу client на другой консоли.
*/ 
#include "common.h"

int
main()
{
int readfd; /* дескриптор для чтения из FIFO */
int n;
char buff[MAX_BUFF]; /* буфер для чтения данных из FIFO */

/* баннер */
printf("FIFO Server...\n");

/* создаем файл FIFO с открытыми для всех
* правами доступа на чтение и запись
*/
if(mknod(FIFO_NAME, S_IFIFO | 0666, 0) < 0)
{
fprintf(stderr, "%s: Невозможно создать FIFO (%s)\n",
     FILE , strerror(errno)); exit(-1);
}

/* откроем FIFO на чтение */
if((readfd = open(FIFO_NAME, O_RDONLY)) < 0)
{
fprintf(stderr, "%s: Невозможно открыть FIFO (%s)\n",
     FILE , strerror(errno)); exit(-2);
}

/* читаем данные из FIFO и выводим на экран */
while((n = read(readfd, buff, MAX_BUFF)) > 0)
{
if(write(1, buff, n) != n)
{
fprintf(stderr, "%s: Ошибка вывода (%s)\n",
     FILE , strerror(errno)); exit(-3);
}
}

close(readfd); /* закроем FIFO */

/* удалим FIFO из системы */
if(unlink(FIFO_NAME) < 0)
{
fprintf(stderr, "%s: Невозможно удалить FIFO (%s)\n",
     FILE , strerror(errno)); exit(-4);
}

exit(0);
}

6.1.1	Файл client.c
/*
client.c - реализация клиента
*
чтобы запустить пример, необходимо:
запустить программу server на одной консоли;
запустить программу client на другой консоли.
*/

#include "common.h"

#define MESSAGE "Hello Server!!!\n"

int
main()
{
int writefd; /* дескриптор для записи в FIFO */
int msglen;

/* баннер */
printf("FIFO Client...\n");

/* получим доступ к FIFO */
if((writefd = open(FIFO_NAME, O_WRONLY)) < 0)
{
fprintf(stderr, "%s: Невозможно открыть FIFO (%s)\n",
     FILE , strerror(errno)); exit(-1);
}

/* передадим сообщение серверу */
msglen = strlen(MESSAGE);
if(write(writefd, MESSAGE, msglen) != msglen)
{
fprintf(stderr, "%s: Ошибка записи в FIFO (%s)\n",
     FILE , strerror(errno)); exit(-2);
}

/* закроем доступ к FIFO */
close(writefd);

exit(0);
}


6.3.4	Файл Makefile
all: server client

server: server.c common.h
gcc server.c -o server 
client: client.c common.h
gcc client.c -o client
clean:
-rm server client *.o


6.4	Последовательность выполнения работы
Изучите приведённые в тексте программы server.c и client.c. Взяв данные примеры за образец, напишите аналогичные программы, внеся следующие измене- ния:
1.	Работает не 1 клиент, а несколько (например, два).
2.	Клиенты передают текущее время с некоторой периодичностью (например, раз в пять секунд). Используйте функцию sleep() для приостановки работы клиента.
3.	Сервер работает не бесконечно, а прекращает работу через некоторое время (на- пример, 30 сек). Используйте функцию clock() для определения времени работы сервера. Что будет в случае, если сервер завершит работу, не закрыв канал?



